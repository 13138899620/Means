1.线程安全的一个判定指标，线程之间有没有临界资源，如果有临界资源，且没有采用合理的同步机制，就会出现多个线程竞争一个资源，如若多个线程都在为得不到所需的资源，则会发生死锁。死锁，线程就会彼此僵持，系统停滞不前，如果后果严重，则直接导致系统崩溃。

2.线程可以大大提高应用程序的可用性和性能，但是多线程也给我们带来一些新的挑战，要不要使用多线程，如何使用多线程，需要根据实际情况而定。
(1) 复杂度        使用多线程，可能使得应用程序复杂度明显提高，特别是要处理线程同步和死锁问题。需要仔细地评估应该在何处使用多线程和如何使用多线程，这样就可以获得最大的好处，而无需创建不必要的复杂并难于调试的应用程序。

(2) 数量     线程不易过多，线程的数量与服务器配置（多核、多处理器）、业务处理具体过程，都有直接关系。线程量过少，不能充分发挥服务器的处理能力，也不能有效改善事务的处理效率。线程量过多，需要花费大量的时间来进行线程控制，最后得不偿失。可以根据实际情况，通过检验测试，设定一个特定的合理的范围

(3) 同步和异步调用的选择
应用程序既可以进行同步调用，也可以进行异步调用。同步，调用在继续之前等待响应或返回值。如果不允许调用继续，就说调用被阻塞了。异步或非阻塞调用不用等待响应，异步调用是同步使用单独的线程执行的。原始线程异步调用，异步调用使用另一个线程执行请求，而与此同时原始的线程继续处理！ 

(4）前台线程和后台线程之间的选择
.NET Framework 中的所有线程都被指定为前台线程或后台线程。这两种线程唯一的区别是 ― 后台线程不会阻止进程终止。在属于一个进程的所有前台线程终止之后，公共语言运行库 (CLR) 就会结束进程，从而终止仍在运行的任何后台线程。
      在默认情况下，通过创建并启动新的 Thread 对象生成的所有线程都是前台线程，而从非托管代码进入托管执行环境中的所有线程都标记为后台线程。然而，通过修改 Thread.IsBackground 属性，可以指定一个线程是前台线程还是后台线程。通过将 Thread.IsBackground 设置为 true，可以将一个线程指定为后台线程；通过将 Thread.IsBackground 设置为 false，可以将一个线程指定为前台线程。

在大多数应用程序中，您会选择将不同的线程设置成前台线程或后台线程。通常，应该将被动侦听活动的线程设置为后台线程，而将负责发送数据的线程设置为前台线程，这样，在所有的数据发送完毕之前该线程不会被终止。只有在确认线程被系统随意终止没有不利影响时，才应该使用后台线程。如果线程正在执行必须完成的敏感操作或事务操作，或者需要控制关闭线程的方式以便释放重要资源，则使用前台线程。


3.ThreadPool

线程管理并不仅仅是每次想要执行一个不同的任务就创建一个新线程的问题。有太多的线程可能会使得应用程序耗费一些不必要的系统资源，特别是，如果有大量短期运行的操作，而所有这些操作都运行在单独线程上。另外，显式地管理大量的线程可能是非常复杂的。

线程池化技术通过给应用程序提供由系统管理的辅助线程池解决了这些问题，从而使得您可以将注意力集中在应用程序任务上而不是线程管理上。

在需要时，可以由应用程序将线程添加到线程池中。当 CLR 最初启动时，线程池没有包含额外的线程。然而，当应用程序请求线程时，它们就会被动态创建并存储在该池中。如果线程在一段时间内没有使用，这些线程就可能会被处置，因此线程池是根据应用程序的要求缩小或扩大的。
注意：每个进程都创建一个线程池，因此，如果您在同一个进程内运行几个应用程序域，则一个应用程序域中的错误可能会影响相同进程内的其他应用程序域，因为它们都使用相同的线程池。

线程池由两种类型的线程组成：

辅助线程。辅助线程是标准系统池的一部分。它们是由 .NET Framework 管理的标准线程，大多数功能都在它们上面执行。

完成端口线程.这种线程用于异步 I/O 操作（通过使用 IOCompletionPorts API）


4.在下面的情况下，使用 ThreadPool 类：

有大量小的独立任务要在后台执行。

不需要对用来执行任务的线程进行精细控制。

Thread是显示来管理线程。只要有可能，就应该使用 ThreadPool 类来创建线程。

5.在下面的情况下，使用 Thread 对象：

需要具有特定优先级的任务。

有可能运行很长时间的任务（这样可能阻塞其他任务）。

需要确保只有一个线程可以访问特定的程序集。

需要有与线程相关的稳定标识。